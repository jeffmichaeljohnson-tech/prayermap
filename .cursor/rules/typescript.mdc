---
description: TypeScript patterns and conventions for PrayerMap
globs:
  - "**/*.ts"
  - "**/*.tsx"
alwaysApply: true
---

# TypeScript Conventions

## Strict Mode Requirements
- All code must pass `strict: true` compilation
- No implicit `any` types
- Explicit null checks required
- No unused variables or parameters

## Type Definitions

### Core Types (from `src/types/prayer.ts`)
```typescript
interface Prayer {
  id: string;
  user_id: string;
  title?: string;
  content: string;
  content_type: 'text' | 'audio' | 'video';
  content_url?: string;
  location: { lat: number; lng: number };
  user_name?: string;
  is_anonymous: boolean;
  status?: 'pending' | 'approved' | 'active' | 'hidden' | 'removed';
  created_at: Date;
  updated_at?: Date;
}

interface PrayerResponse {
  id: string;
  prayer_id: string;
  responder_id: string;
  responder_name?: string;
  is_anonymous: boolean;
  message: string;
  content_type: 'text' | 'audio' | 'video';
  content_url?: string;
  created_at: Date;
  read_at?: Date | null;
}

interface PrayerConnection {
  id: string;
  prayerId: string;
  prayerResponseId?: string;
  fromLocation: { lat: number; lng: number };
  toLocation: { lat: number; lng: number };
  requesterName: string;
  replierName: string;
  createdAt: Date;
  expiresAt: Date;
}
```

### Location Type
Always use this format for coordinates:
```typescript
interface Location {
  lat: number;
  lng: number;
}
// NOT { latitude, longitude } or [lng, lat]
```

## Error Handling Pattern
```typescript
try {
  const result = await someAsyncOperation();
  return result;
} catch (error) {
  const message = error instanceof Error ? error.message : 'Unknown error';
  console.error('Operation failed:', error);
  // Either throw, return null, or set error state
  throw new Error(message);
}
```

## Null Safety
```typescript
// Always check before accessing
if (!supabase) {
  console.error('Supabase client not initialized');
  return null;
}

// Use optional chaining
const userName = user?.profile?.display_name ?? 'Anonymous';

// Explicit null checks in conditions
if (data !== null && data !== undefined) {
  // Process data
}
```

## Function Signatures
```typescript
// Exported functions need explicit return types
export async function fetchPrayers(): Promise<Prayer[]> {
  // ...
}

// Use generics for reusable utilities
export function createSubscription<T>(
  channel: string,
  callback: (data: T) => void
): () => void {
  // Returns unsubscribe function
}
```

## Enums vs Union Types
Prefer union types over enums:
```typescript
// Preferred
type ContentType = 'text' | 'audio' | 'video';
type PrayerStatus = 'pending' | 'approved' | 'active' | 'hidden' | 'removed';

// Avoid
enum ContentType { Text, Audio, Video }
```

## Import Organization
```typescript
// 1. React imports
import { useState, useEffect, useCallback } from 'react';

// 2. Third-party imports
import { motion } from 'framer-motion';
import mapboxgl from 'mapbox-gl';

// 3. Internal imports - types
import type { Prayer, PrayerResponse } from '@/types/prayer';

// 4. Internal imports - components
import { Button } from '@/components/ui/button';

// 5. Internal imports - utilities
import { supabase } from '@/lib/supabase';
```

## Type Assertions
Avoid type assertions when possible. If needed:
```typescript
// Prefer type guards
function isPrayer(obj: unknown): obj is Prayer {
  return typeof obj === 'object' && obj !== null && 'id' in obj;
}

// If assertion needed, use 'as' not angle brackets
const prayer = data as Prayer;  // OK
const prayer = <Prayer>data;    // Avoid (JSX conflict)
```
